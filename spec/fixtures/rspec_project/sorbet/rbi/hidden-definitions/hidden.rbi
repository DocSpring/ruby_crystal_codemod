# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def lockfile_upgrade_warning?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration::MoreFuture
  def default_stubs(); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Byebug
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
end

class Byebug::FullpathSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::WidthSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*_); end
end

class CodeRay::Encoders::Encoder
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::PluginHost
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*_); end

  def tokens(*_); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::SpellChecker
  def correct(input); end

  def initialize(dictionary:); end
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def zip(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

module Exception2MessageMapper
  def bind(cl); end

end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def resume(*_); end
end

class Fiber
  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
end

class FrozenError
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

class Gelauto::ArgList
  include ::Enumerable
  def <<(arg); end

  def [](idx); end

  def args(); end

  def each(&block); end

  def empty?(); end

  def initialize(args=T.unsafe(nil)); end

  def to_sig(); end
end

class Gelauto::ArgList
end

module Gelauto::CLIUtils
  def which(cmd); end
  EXTS = ::T.let(nil, ::T.untyped)
end

module Gelauto::CLIUtils
  extend ::Gelauto::CLIUtils
end

module Gelauto::Logger
end

module Gelauto::Logger
  def self.debug(str); end

  def self.error(str); end

  def self.fatal(str); end

  def self.info(str); end

  def self.warn(str); end
end

class Gelauto::MethodDef
  def args(); end

  def initialize(name, args, nesting, return_types=T.unsafe(nil)); end

  def name(); end

  def nesting(); end

  def return_types(); end

  def to_rbi(); end

  def to_sig(); end
end

class Gelauto::MethodDef
end

class Gelauto::MethodIndex
  def annotate(path, code); end

  def each(&blk); end

  def each_method_in(path); end

  def find(path, lineno); end

  def index(); end

  def index_methods_in(path, ast, nesting=T.unsafe(nil)); end

  def reset(); end
end

class Gelauto::MethodIndex
end

class Gelauto::Namespace
  def initialize(name, type); end

  def name(); end

  def type(); end
end

class Gelauto::Namespace
end

class Gelauto::NullLogger
  def debug(*_); end

  def error(*_); end

  def fatal(*_); end

  def info(*_); end

  def initialize(*_); end

  def warn(*_); end
end

class Gelauto::NullLogger
end

class Gelauto::Rbi
  def initialize(method_index, paths=T.unsafe(nil)); end

  def method_index(); end

  def paths(); end
end

class Gelauto::Rbi
end

class Gelauto::TypeSet
  include ::Enumerable
  def <<(type); end

  def each(&block); end

  def empty?(); end

  def merge!(other); end

  def set(); end

  def size(); end

  def to_sig(); end
end

class Gelauto::TypeSet
end

module Gelauto::Utils
  def each_absolute_path(paths); end
end

module Gelauto::Utils
  extend ::Gelauto::Utils
end

class Gelauto::Var
  def initialize(name, types=T.unsafe(nil)); end

  def name(); end

  def to_sig(); end

  def types(); end

  def types=(types); end
end

class Gelauto::Var
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Specification
  extend ::Enumerable
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(*_); end
end

class Hash
  def self.try_convert(_); end
end

class IO
  def external_encoding(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def pread(*_); end

  def pwrite(_, _1); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Abort
end

class IRB::Abort
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def ap_name(); end

  def ap_name=(ap_name); end

  def auto_indent_mode(); end

  def auto_indent_mode=(auto_indent_mode); end

  def back_trace_limit(); end

  def back_trace_limit=(back_trace_limit); end

  def debug?(); end

  def debug_level(); end

  def debug_level=(value); end

  def echo(); end

  def echo=(echo); end

  def echo?(); end

  def eval_history=(*opts, &b); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def exit(ret=T.unsafe(nil)); end

  def file_input?(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ignore_eof?(); end

  def ignore_sigint(); end

  def ignore_sigint=(ignore_sigint); end

  def ignore_sigint?(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect?(); end

  def inspect_last_value(); end

  def inspect_mode(); end

  def inspect_mode=(opt); end

  def io(); end

  def io=(io); end

  def irb(); end

  def irb=(irb); end

  def irb_name(); end

  def irb_name=(irb_name); end

  def irb_path(); end

  def irb_path=(irb_path); end

  def last_value(); end

  def load_modules(); end

  def load_modules=(load_modules); end

  def main(); end

  def prompt_c(); end

  def prompt_c=(prompt_c); end

  def prompt_i(); end

  def prompt_i=(prompt_i); end

  def prompt_mode(); end

  def prompt_mode=(mode); end

  def prompt_n(); end

  def prompt_n=(prompt_n); end

  def prompt_s(); end

  def prompt_s=(prompt_s); end

  def prompting?(); end

  def rc(); end

  def rc=(rc); end

  def rc?(); end

  def return_format(); end

  def return_format=(return_format); end

  def save_history=(*opts, &b); end

  def set_last_value(value); end

  def thread(); end

  def use_loader=(*opts, &b); end

  def use_readline(); end

  def use_readline=(opt); end

  def use_readline?(); end

  def use_tracer=(*opts, &b); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end

  def workspace(); end

  def workspace=(workspace); end

  def workspace_home(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
end

module IRB::ContextExtender
end

IRB::ContextExtender::CE = IRB::ContextExtender

module IRB::ContextExtender
  def self.def_extend_command(cmd_name, load_file, *aliases); end

  def self.install_extend_commands(); end
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override=T.unsafe(nil)); end

  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_context(); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_exit(ret=T.unsafe(nil)); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_load(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_require(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.def_extend_command(cmd_name, cmd_class, load_file=T.unsafe(nil), *aliases); end

  def self.extend_object(obj); end

  def self.install_extend_commands(); end

  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(file); end
end

class IRB::FileInputMethod
end

class IRB::InputMethod
  def file_name(); end

  def gets(); end

  def initialize(file=T.unsafe(nil)); end

  def prompt(); end

  def prompt=(prompt); end

  def readable_after_eof?(); end
end

class IRB::InputMethod
end

class IRB::Inspector
  def init(); end

  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end

  def inspect_value(v); end
  INSPECTORS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def self.def_inspector(key, arg=T.unsafe(nil), &block); end

  def self.keys_with_inspector(inspector); end
end

class IRB::Irb
  def context(); end

  def eval_input(); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end

  def run(conf=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def signal_handle(); end

  def signal_status(status); end

  def suspend_context(context); end

  def suspend_input_method(input_method); end

  def suspend_name(path=T.unsafe(nil), name=T.unsafe(nil)); end

  def suspend_workspace(workspace); end
  ATTR_PLAIN = ::T.let(nil, ::T.untyped)
  ATTR_TTY = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end

  def def_pre_proc(base_method, extend_method); end

  def new_alias_name(name, prefix=T.unsafe(nil), postfix=T.unsafe(nil)); end
end

module IRB::MethodExtender
end

module IRB::Notifier
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
  D_NOMSG = ::T.let(nil, ::T.untyped)
end

class IRB::Notifier::AbstractNotifier
  def exec_if(); end

  def initialize(prefix, base_notifier); end

  def notify?(); end

  def ppx(prefix, *objs); end

  def prefix(); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::Notifier::AbstractNotifier
end

class IRB::Notifier::CompositeNotifier
  def def_notifier(level, prefix=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def level_notifier(); end

  def level_notifier=(value); end

  def notifiers(); end
end

class IRB::Notifier::CompositeNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::LeveledNotifier
  include ::Comparable
  def initialize(base, level, prefix); end

  def level(); end
end

class IRB::Notifier::LeveledNotifier
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::Notifier::NoMsgNotifier
end

module IRB::Notifier
  extend ::Exception2MessageMapper
  def self.def_notifier(prefix=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def self.included(mod); end
end

class IRB::OutputMethod
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def parse_printf_format(format, opts); end

  def ppx(prefix, *objs); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::ReadlineInputMethod
  include ::Readline
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReadlineInputMethod
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::StdioInputMethod
end

class IRB::StdioOutputMethod
end

class IRB::StdioOutputMethod
end

class IRB::WorkSpace
  def code_around_binding(); end

  def evaluate(context, statements, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def filter_backtrace(bt); end

  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end

  def main(); end
end

class IRB::WorkSpace
end

module IRB
  def self.CurrentContext(); end

  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.conf(); end

  def self.default_src_encoding(); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.irb_abort(irb, exception=T.unsafe(nil)); end

  def self.irb_at_exit(); end

  def self.irb_exit(irb, ret); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.start(ap_path=T.unsafe(nil)); end

  def self.version(); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Marshal
  def self.restore(*_); end
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

class Module
  def deprecate_constant(*_); end

  def undef_method(*_); end
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

class Net::HTTP
end

Net::HTTPSession::ProxyDelta = Net::HTTP::ProxyDelta

Net::HTTPSession::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP
end

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Parser::CurrentRuby = Parser::Ruby26

class Parser::Diagnostic
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  NUMPARAM_MAX = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby26
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

class Pry
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  CLIPPED_PRINT = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  DEFAULT_CONTROL_D_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_WHITELIST = ::T.let(nil, ::T.untyped)
  DEFAULT_HOOKS = ::T.let(nil, ::T.untyped)
  DEFAULT_PRINT = ::T.let(nil, ::T.untyped)
  DEFAULT_SYSTEM = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HOME_RC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  SIMPLE_PRINT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::Pry = Pry

class Pry::Code
  extend ::MethodSource::CodeHelpers
end

class Pry::CodeFile
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::ColorPrinter
  OBJ_COLOR = ::T.let(nil, ::T.untyped)
end

class Pry::Command
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemSearch
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemStat
  FAIL_WHALE = ::T.let(nil, ::T.untyped)
  STAT_HOST = ::T.let(nil, ::T.untyped)
  STAT_PATH = ::T.let(nil, ::T.untyped)
  STAT_PORT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Behavior
  ASSIGNMENT = ::T.let(nil, ::T.untyped)
  INSPECT_REGEXP = ::T.let(nil, ::T.untyped)
  NODUP = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Convenience
  SHORTCUTS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Memoization
  MEMOIZED_METHODS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  COLORS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

module Pry::Prompt
  DEFAULT_NAME = ::T.let(nil, ::T.untyped)
  SAFE_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::DidYouMean
  def call(); end

  def initialize(relative_file_name); end

  def relative_file_name(); end
end

class RSpec::Core::DidYouMean
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterRules
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::FailureListFormatter
  def dump_profile(_profile); end

  def example_failed(failure); end

  def message(_message); end
end

class RSpec::Core::Formatters::FailureListFormatter
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Hooks::HookCollections
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Pending
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
end

class RSpec::Expectations::FailureAggregator
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(*args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *_); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
end

class RSpec::Matchers::BuiltIn::Compound
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message=T.unsafe(nil), expected_message=T.unsafe(nil), &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def with_message(expected_message); end
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  def at_least(number); end

  def at_most(number); end

  def does_not_match?(block); end

  def exactly(number); end

  def initialize(); end

  def matches?(block); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::DSL::Macros
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::AnyInstance
end

class RSpec::Mocks::AnyInstance::Chain
  include ::RSpec::Mocks::AnyInstance::Chain::Customizations
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::Chain
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::MessageChains
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Proxy
end

class RSpec::Mocks::AnyInstance::Recorder
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::Recorder
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::StubChainChain
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::ArgumentListMatcher
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ExpectChain
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

class RSpec::Mocks::MarshalExtension
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

class RSpec::Mocks::Matchers::HaveReceived
  include ::RSpec::Mocks::Matchers::Matcher
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matches?(subject, &block); end

  def name(); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
end

class RSpec::Mocks::Matchers::Receive
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, &block); end

  def initialize(message, block); end

  def matches?(subject, &block); end

  def name(); end

  def never(*args, &block); end

  def once(*args, &block); end

  def ordered(*args, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
end

class RSpec::Mocks::Matchers::Receive
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matches?(subject, &block); end

  def name(); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
end

class RSpec::Mocks::Matchers::ReceiveMessages
  include ::RSpec::Mocks::Matchers::Matcher
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matches?(subject); end

  def name(); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageChain
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::StubChain
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::EncodedString
  ENCODE_NO_CONVERTER = ::T.let(nil, ::T.untyped)
  ENCODE_UNCONVERTABLE_BYTES = ::T.let(nil, ::T.untyped)
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
  INFINITY = ::T.let(nil, ::T.untyped)
end

RSpec::Support::Mutex = Thread::Mutex

class RSpec::Support::ObjectFormatter
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Scope
  EMPTY = ::T.let(nil, ::T.untyped)
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake
  extend ::FileUtils::StreamUtils_
end

RakeFileUtils = Rake::FileUtilsExt

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  extend ::Random::Formatter
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Readline
  def self.basic_quote_characters(); end

  def self.basic_quote_characters=(basic_quote_characters); end

  def self.basic_word_break_characters(); end

  def self.basic_word_break_characters=(basic_word_break_characters); end

  def self.completer_quote_characters(); end

  def self.completer_quote_characters=(completer_quote_characters); end

  def self.completer_word_break_characters(); end

  def self.completer_word_break_characters=(completer_word_break_characters); end

  def self.completion_append_character(); end

  def self.completion_append_character=(completion_append_character); end

  def self.completion_case_fold(); end

  def self.completion_case_fold=(completion_case_fold); end

  def self.completion_proc(); end

  def self.completion_proc=(completion_proc); end

  def self.completion_quote_character(); end

  def self.delete_text(*_); end

  def self.emacs_editing_mode(); end

  def self.emacs_editing_mode?(); end

  def self.filename_quote_characters(); end

  def self.filename_quote_characters=(filename_quote_characters); end

  def self.get_screen_size(); end

  def self.input=(input); end

  def self.insert_text(_); end

  def self.line_buffer(); end

  def self.output=(output); end

  def self.point(); end

  def self.point=(point); end

  def self.pre_input_hook(); end

  def self.pre_input_hook=(pre_input_hook); end

  def self.quoting_detection_proc(); end

  def self.quoting_detection_proc=(quoting_detection_proc); end

  def self.redisplay(); end

  def self.refresh_line(); end

  def self.set_screen_size(_, _1); end

  def self.special_prefixes(); end

  def self.special_prefixes=(special_prefixes); end

  def self.vi_editing_mode(); end

  def self.vi_editing_mode?(); end
end

class Regexp
  def match?(*_); end
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end

  def self.stat(*_); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.rails_load_paths(); end

  def self.rb_file_paths(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

YAML = Psych

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
